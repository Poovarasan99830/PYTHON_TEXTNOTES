

# ______________________________________
**Asynchronous Programming**
# ______________________________________

* Programming method where **tasks donâ€™t block each other**.
* While one task is waiting (API, DB, I/O), the program continues doing **other work**.
* Achieves **concurrency without multiple threads**.

---

# ______________________________________
â†’ Definition
# ______________________________________


### âœ… Definition

**Asynchronous Programming** in Python means writing **tasks (functions) that can pause and resume** so multiple operations can run **concurrently in a single thread**.

* **asyncio** library â†’ official async library in Python
* **Coroutines** â†’ functions that can pause/resume (`async def`)
* **await** â†’ pauses until the awaited coroutine completes

**Good for:** API calls, file downloads, DB queries, networking.
**Not ideal for:** heavy CPU-bound tasks.

---

# ______________________________________
â†’ Real-time Examples
# ______________________________________


1. Fetch multiple API responses at the same time (User data, Orders, Payments).
2. Download multiple files simultaneously.
3. Chat application: multiple users sending messages.
4. Drone sensors: GPS, battery, object tracking concurrently.
5. Gaming engine: physics, audio, rendering updates concurrently.

---

# ______________________________________
â†’ N Examples
# ______________________________________



# ______________________________________
# Example1
# ______________________________________




```python

import asyncio

async def do_work(name, seconds):
    print(f"{name} started (will take {seconds}s)")
    await asyncio.sleep(seconds)
    print(f"{name} finished")
    return f"{name}-result"


async def main():
    t1 = asyncio.create_task(do_work("Job-A", 2))
    t2 = asyncio.create_task(do_work("Job-B", 1))
    t3 = asyncio.create_task(do_work("Job-C", 3))

    await t1
    await t2
    await t3


asyncio.run(main())



# ______________________________________
# Example2
# ______________________________________


import asyncio

async def Cook(work, seconds):
    print(f"{work} started (will take {seconds}s)")
    await asyncio.sleep(seconds)
    print(f"{cook} finished")
  


async def main():
    t1 = asyncio.create_task(do_work("cook rice", 2))
    t2 = asyncio.create_task(do_work("cut "vegetables, 1))
    
    await asyncio.gather(t1,t2)

asyncio.run(main())





# ______________________________________
â†’ Tasks
# ______________________________________


1. Write an async function to print 1â€“5 numbers with delay 1s each.
2. Write async functions to fetch three API endpoints concurrently.
3. Create coroutines to simulate downloading 5 files simultaneously.
4. Implement drone sensor reading coroutines concurrently.
5. Simulate chat messages being sent asynchronously from multiple users.


# ______________________________________
â†’ Task Explanation
# ______________________________________


# ______________________________________
**Task 1 :Write an async function to print 1â€“5 numbers with delay 1s each.
# ______________________________________





```python
import asyncio

async def numbers(name):
    for i in range(1,6):
        print(f"{name} â†’ {i}")
        await asyncio.sleep(1)

async def main():
    t1 = asyncio.create_task(numbers("Thread-1"))
    t2 = asyncio.create_task(numbers("Thread-2"))
    await asyncio.gather(t1,t2)

asyncio.run(main())
```




**#CODE Explanation**

* **Purpose:** Run multiple number-print tasks concurrently without blocking
* **Concept:** Each coroutine pauses at `await`, event loop runs other coroutines
* **Code:** `create_task()` registers task, `await gather()` waits all to finish
* **Flow:** t1 prints 1 â†’ pause â†’ t2 prints 1 â†’ pause â†’ t1 prints 2 â†’ â€¦
* **Output:** Numbers from both tasks interleaved concurrently
* **Benefit:** Single thread handles multiple tasks efficiently



# ______________________________________
Task 2:. Write async functions to fetch three API endpoints concurrently.
# ______________________________________


```python

import asyncio

async def fetch(name, delay):
    print(f"{name} started")
    await asyncio.sleep(delay)
    print(f"{name} finished")
    return f"{name}-result"

async def main():
    tasks = [
        asyncio.create_task(fetch("User", 2)),
        asyncio.create_task(fetch("Orders", 1)),
        asyncio.create_task(fetch("Payments", 3))
    ]
    results = await asyncio.gather(*tasks)
    print("Results:", results)

asyncio.run(main())
```


**#CODE Explanation**


**Purpose:** Run multiple API-like operations (User, Orders, Payments) concurrently without blocking.
**Concept:** `async` + `await` lets tasks pause during I/O and event loop runs another task meanwhile.
**Code:** `create_task()` schedules three fetch operations, and `gather()` waits for all tasks to finish.
**Flow:** Shortest delay finishes first â†’ event loop switches tasks â†’ all complete â†’ results returned in order.
**Output:** Three â€œstarted/finishedâ€ prints and a final list: `['User-result','Orders-result','Payments-result']`.
**Benefit:** Handles multiple I/O operations efficiently without threads or blocking.



# ______________________________________
Task 3: Create coroutines to simulate downloading 5 files simultaneously.
# ______________________________________



```python
import asyncio

async def download(file):
    print(f"Start downloading {file}")
    await asyncio.sleep(2)
    print(f"{file} downloaded")

async def main():
    files = ["file1.pdf", "file2.jpg", "file3.mp4"]
    tasks = [asyncio.create_task(download(f)) for f in files]
    await asyncio.gather(*tasks)

asyncio.run(main())
```




**#CODE Explanation**

**Purpose:** Download multiple files concurrently for faster completion.
**Concept:** Each `download()` async function suspends during `sleep`, allowing event loop to run other tasks.
**Code:** Three tasks created with `create_task()`, and `gather()` ensures all downloads finish.
**Flow:** Downloads start â†’ event loop switches during await â†’ tasks finish independently â†’ main continues.
**Output:** Three â€œdownloadedâ€ messages printed, order based on delay.
**Benefit:** Greatly reduces total download time by overlapping I/O waits.




# ______________________________________
Task 4: Implement drone sensor reading coroutines concurrently.
# ______________________________________


```python
import asyncio

async def gps():
    await asyncio.sleep(1)
    print("GPS done")

async def battery():
    await asyncio.sleep(2)
    print("Battery check done")

async def tracking():
    await asyncio.sleep(3)
    print("Object tracking done")

async def main():
    tasks = [asyncio.create_task(gps()), asyncio.create_task(battery()), asyncio.create_task(tracking())]
    await asyncio.gather(*tasks)

asyncio.run(main())
```

* Multiple sensors running concurrently
* Event loop switches between tasks during `await`



**#CODE Explanation**

**Purpose:** Run GPS, battery check, and object tracking concurrently like real drone sensors.
**Concept:** Async tasks simulate sensors working in parallel without blocking each other.
**Code:** Three tasks created for gps(), battery(), tracking(), and gathered for completion.
**Flow:** Event loop alternates between sensors during each `await` â†’ all complete independently.
**Output:** â€œGPS doneâ€, â€œBattery check doneâ€, â€œObject tracking doneâ€ printed in order of delays.
**Benefit:** Perfect for real-time systems where multiple sensor tasks must run together smoothly.



# ______________________________________
Task 5:Simulate chat messages being sent asynchronously from multiple users.
# ______________________________________

```python

import asyncio
import random

async def send_message(user, msg):
    delay = random.uniform(0.5, 2.0)
    await asyncio.sleep(delay)
    print(f"{user}: {msg}")

async def main():
    messages = [
        ("Alice", "Hello!"),
        ("Bob", "How are you?"),
        ("Charlie", "Anyone online?"),
        ("Diana", "Let's start the meeting."),
        ("Evan", "I'm joining now!")
    ]

    tasks = [asyncio.create_task(send_message(u, m)) for u, m in messages]
    await asyncio.gather(*tasks)

asyncio.run(main())
```



**#CODE Explanation**

**Purpose:** Simulate multiple users sending chat messages at different times without blocking each other.
**Concept:** Each chat message is an async task that waits using `sleep()`, allowing event loop to run other messages.
**Code:** `create_task()` schedules chat sends for 5 users, and `gather()` waits until all messages are delivered.
**Flow:** Each message gets a random delay â†’ event loop switches between tasks â†’ messages print in random order.
**Output:** Chat messages appear like a real chat room: mixed, unordered, arriving as soon as each task completes.
**Benefit:** Demonstrates realistic asynchronous behavior where multiple users interact concurrently without threads.




# ______________________________________
   MEMORY ARCHITECTURE
# ______________________________________





===============================
        OPERATING SYSTEM
===============================
            â†“
       Python Process
       (Allocated in RAM)
-------------------------------
          Main Thread
-------------------------------
          | (Inside RAM)
          |
          |-- Python Interpreter
          |      |
          |      |-- Event Loop Object
          |      |       - Task Queue
          |      |       - Ready Queue
          |      |       - Timers (sleep)
          |      |
          |      |-- Coroutine Objects
          |      |       - do_work("A")
          |      |       - do_work("B")
          |      |       - do_work("C")
          |      |
          |      |-- Task Wrappers
          |              - t1
          |              - t2
          |              - t3
          |
          |-- Call Stack
          |      |
          |      |-- main()
          |      |-- await gather()
          |
          |-- Heap Memory
                 |
                 |-- Variables, objects, strings,
                 |   coroutines, tasks, event-loop,
                 |   sleep timers, etc.


-------------------------------

# Memory Architect Working Flow Explanation:

-------------------------------


1ï¸âƒ£ Program Start
   â””â”€> OS loads Python process into RAM
        - Python Process created
        - Memory allocated

2ï¸âƒ£ Main Thread Starts
   â””â”€> main() function called
        - Call Stack: main()
        - Python interpreter ready

3ï¸âƒ£ Event Loop Creation
   â””â”€> asyncio.run(main()) â†’ Event Loop object created
        - Inside Event Loop:
            â€¢ Task Queue (empty initially)
            â€¢ Ready Queue
            â€¢ Waiting Queue
            â€¢ Timers
            â€¢ Callback list

4ï¸âƒ£ Task Registration
   â”œâ”€ t1 = create_task(do_work("A",2))
   â”œâ”€ t2 = create_task(do_work("B",1))
   â””â”€ t3 = create_task(do_work("C",3))
        â€¢ Each task wrapper created
        â€¢ Coroutine objects stored in Heap
        â€¢ Task state = CREATED
        â€¢ Tasks added to Event Loopâ€™s Task Queue
        â€¢ No task runs yet

5ï¸âƒ£ Event Loop Scheduling (Time 0s)
   â””â”€ Event Loop picks tasks from Task Queue one by one
        â”œâ”€ t1 â†’ RUNNING â†’ prints "Job-A started" â†’ hits await sleep(2) â†’ WAITING
        â”œâ”€ t2 â†’ RUNNING â†’ prints "Job-B started" â†’ hits await sleep(1) â†’ WAITING
        â””â”€ t3 â†’ RUNNING â†’ prints "Job-C started" â†’ hits await sleep(3) â†’ WAITING
   Output: Job-A started, Job-B started, Job-C started

6ï¸âƒ£ Waiting / Timer Phase
   â””â”€ Event Loop sleeps while tasks are in WAITING
        - t1 waiting 2s
        - t2 waiting 1s
        - t3 waiting 3s

7ï¸âƒ£ Timer Expiry & Resume
   â”œâ”€ Time 1s â†’ t2 timer done â†’ READY â†’ RUNNING â†’ FINISHED â†’ Output: Job-B finished
   â”œâ”€ Time 2s â†’ t1 timer done â†’ READY â†’ RUNNING â†’ FINISHED â†’ Output: Job-A finished
   â””â”€ Time 3s â†’ t3 timer done â†’ READY â†’ RUNNING â†’ FINISHED â†’ Output: Job-C finished

8ï¸âƒ£ await gather() Completion
   â””â”€ Event Loop confirms all tasks finished
   â””â”€ main() resumes â†’ Call Stack continues â†’ main() ends

9ï¸âƒ£ Event Loop Closes
   â””â”€ Python interpreter cleans up
   â””â”€ Program exits




# ____________________________________________________________

# Summary

* **async def** â†’ creates a coroutine (an async function that can be paused and resumed).
* **await** â†’ pauses the current coroutine and resumes when the awaited task completes.
* **create_task()** â†’ registers the coroutine as a task in memory and schedules it for the event loop to run.
* **gather()** â†’ waits until all scheduled tasks are completed and returns their results.
* **Event loop** â†’ acts as the scheduler, timer, and task queue manager for all async operations.
* **Non-blocking** â†’ tasks with shorter sleep or faster I/O finish earlier without waiting for others.
* **Single-threaded concurrency** â†’ safe, lightweight execution without race conditions or thread overhead.




# ______________________________________

# âœ… **Why do we use Asynchronous Programming? What happens if we donâ€™t use it?**......
# ______________________________________





# ______________________________________
# DIFFERENCE BETWEEN MULTITHREADING ,MULTIPROCESSING,ASYNCHRONOUS
# ______________________________________








# ____________________________________________
Quick Answer:
# ____________________________________________

- Multithreading: Multiple threads within the same process share memory, good for I/O-bound tasks.
- Multiprocessing: Multiple processes with separate memory spaces, ideal for CPU-bound tasks.
- Asynchronous programming: Single-threaded but non-blocking, tasks yield control until results are ready, great for handling many concurrent I/O operations.



# ____________________________________________
ğŸ§µ Multithreading
# ____________________________________________


- Definition: Runs multiple threads inside one process.
- Memory: Threads share the same memory space.
- Best for: I/O-bound tasks (e.g., waiting for network or disk).
- Pros: Lightweight, faster context switching than processes.
- Cons: Risk of race conditions and deadlocks since threads share memory.


# ____________________________________________
ğŸ–¥ï¸ Multiprocessing
# ____________________________________________



- Definition: Runs multiple processes, each with its own memory space.
- Memory: Processes are isolated; no shared memory by default.
- Best for: CPU-bound tasks (e.g., heavy computations, data processing).
- Pros: Can fully utilize multiple CPU cores.
- Cons: Higher overhead due to inter-process communication (IPC).


# ____________________________________________
âš¡ Asynchronous Programming
# ____________________________________________



- Definition: Single-threaded, event-driven execution where tasks donâ€™t block each other.
- Mechanism: Uses callbacks, promises, or async/await to yield control until results are ready.
- Best for: High-concurrency I/O tasks (e.g., web servers handling thousands of requests).
- Pros: Efficient resource usage, avoids blocking.
- Cons: Harder to debug and reason about compared to synchronous code.




# ______________________________END__________________________________________