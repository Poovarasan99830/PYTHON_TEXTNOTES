Perfect ğŸ‘ You want **lambda, iterator, and generator** concepts explained and structured like we did for **recursion** (definition â†’ key points â†’ real-life example â†’ code examples â†’ tasks â†’ practice problems).

Hereâ€™s the formatted content for all three:

---

# \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

# ğŸ”¹ 2. **Lambda (Anonymous Function)**

### âœ… Definition

* A **lambda function** is a small **anonymous function** (without a name).
* Used for **short, one-line functions**.

### ğŸ”‘ Key Points

* Syntax: `lambda arguments: expression`
* Can take **any number of arguments**, but only **one expression**.
* Often used with `map()`, `filter()`, `reduce()`.

### ğŸ“Œ Example

```python
# Normal function
def square(x):
    return x * x

# Lambda function
square_lambda = lambda x: x * x

print(square_lambda(5))  # 25
```

â¡ï¸ Real life: Used in **sorting**, **filtering**, and **quick inline functions**.

---

### ğŸ¯ Tasks

1. Write a lambda function to add two numbers.
2. Write a lambda function to check if a number is even.
3. Write a lambda function to get the last character of a string.
4. Use `map()` with lambda to square a list of numbers.
5. Use `filter()` with lambda to find numbers divisible by 3.
6. Use `reduce()` with lambda to calculate factorial.

---

# \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

# ğŸ”¹ 3. **Iterator**

### âœ… Definition

* An **iterator** is an object that allows you to **traverse elements one at a time**.
* Implemented using **`iter()`** and **`next()`**.

### ğŸ”‘ Key Points

* Iterable â†’ any object that can return an iterator (`list`, `tuple`, `dict`, `set`).
* Iterator â†’ object with `__iter__()` and `__next__()` methods.
* Raises **StopIteration** when no elements left.

### ğŸ“Œ Example

```python
nums = [1, 2, 3]
it = iter(nums)

print(next(it))  # 1
print(next(it))  # 2
print(next(it))  # 3
# next(it) â†’ StopIteration
```

â¡ï¸ Real life: Like a **remote control** â€“ you click "next" to go to the next channel.

---

### ğŸ¯ Tasks

1. Create an iterator to print numbers from 1 to 5.
2. Write a custom iterator class to generate squares of numbers.
3. Use iterator to traverse a string character by character.
4. Use `iter()` and `next()` on a tuple.
5. Handle `StopIteration` using `try-except`.

---

# \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

# ğŸ”¹ 4. **Generator**

### âœ… Definition

* A **generator** is a function that returns an **iterator** using `yield`.
* Unlike normal functions, **doesnâ€™t store entire sequence in memory** â†’ generates values one by one.

### ğŸ”‘ Key Points

* Defined with **`yield`** instead of `return`.
* Saves memory â†’ **lazy evaluation**.
* Automatically implements `__iter__()` and `__next__()`.

### ğŸ“Œ Example

```python
def generate_numbers(n):
    for i in range(1, n+1):
        yield i

gen = generate_numbers(5)
for num in gen:
    print(num)  
```

â¡ï¸ Real life: Like a **water tap** â€“ water (values) comes only when you open it (next call).

---

### ğŸ¯ Tasks

1. Write a generator that yields numbers from 1 to 10.
2. Write a generator for Fibonacci numbers.
3. Write a generator that yields even numbers up to `n`.
4. Write a generator that yields characters of a string.
5. Write a generator that yields infinite natural numbers.
6. Write a generator to yield prime numbers up to `n`.

---

# \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

ğŸ‘‰ Now you have **Recursion, Lambda, Iterator, Generator** in the **same format** ğŸ¯

Do you want me to also **add solved examples** for all tasks (like we did for recursion: Fibonacci, reverse string, sum of digits) â€” or should I just leave the task list for practice?


Super ğŸ‘ Letâ€™s extend it just like **recursion** (where I gave solved code for Fibonacci, reverse string, sum of digits).
Here Iâ€™ll provide **solutions for Lambda, Iterator, and Generator tasks**.

---

# ğŸ”¹ 2. **Lambda â€“ Tasks with Solutions**

### âœ… 1. Add two numbers

```python
add = lambda a, b: a + b
print(add(5, 3))  # 8
```

### âœ… 2. Check even number

```python
is_even = lambda x: x % 2 == 0
print(is_even(10))  # True
```

### âœ… 3. Last character of string

```python
last_char = lambda s: s[-1]
print(last_char("hello"))  # "o"
```

### âœ… 4. Square numbers with map()

```python
nums = [1, 2, 3, 4]
squares = list(map(lambda x: x**2, nums))
print(squares)  # [1, 4, 9, 16]
```

### âœ… 5. Divisible by 3 using filter()

```python
nums = [1, 2, 3, 4, 5, 6, 9]
div_by_3 = list(filter(lambda x: x % 3 == 0, nums))
print(div_by_3)  # [3, 6, 9]
```

### âœ… 6. Factorial with reduce()

```python
from functools import reduce
n = 5
fact = reduce(lambda a, b: a*b, range(1, n+1))
print(fact)  # 120
```

---

# ğŸ”¹ 3. **Iterator â€“ Tasks with Solutions**

### âœ… 1. Numbers 1 to 5

```python
nums = iter([1, 2, 3, 4, 5])
for n in nums:
    print(n)
```

### âœ… 2. Custom iterator for squares

```python
class SquareIterator:
    def __init__(self, n):
        self.n = n
        self.current = 1

    def __iter__(self):
        return self

    def __next__(self):
        if self.current <= self.n:
            result = self.current ** 2
            self.current += 1
            return result
        else:
            raise StopIteration

squares = SquareIterator(5)
for val in squares:
    print(val)  # 1,4,9,16,25
```

### âœ… 3. Traverse string

```python
s = "hello"
it = iter(s)
for ch in it:
    print(ch)
```

### âœ… 4. Iterator on tuple

```python
t = (10, 20, 30)
it = iter(t)
print(next(it))  # 10
print(next(it))  # 20
print(next(it))  # 30
```

### âœ… 5. Handle StopIteration

```python
nums = [1, 2]
it = iter(nums)
try:
    while True:
        print(next(it))
except StopIteration:
    print("End of iteration")
```

---

# ğŸ”¹ 4. **Generator â€“ Tasks with Solutions**

### âœ… 1. Numbers 1 to 10

```python
def numbers():
    for i in range(1, 11):
        yield i

for n in numbers():
    print(n)
```

### âœ… 2. Fibonacci

```python
def fibonacci(n):
    a, b = 0, 1
    for _ in range(n):
        yield a
        a, b = b, a + b

print(list(fibonacci(7)))  # [0, 1, 1, 2, 3, 5, 8]
```

### âœ… 3. Even numbers up to n

```python
def evens(n):
    for i in range(2, n+1, 2):
        yield i

print(list(evens(10)))  # [2, 4, 6, 8, 10]
```

### âœ… 4. Characters of string

```python
def chars(s):
    for c in s:
        yield c

print(list(chars("hi")))  # ['h', 'i']
```

### âœ… 5. Infinite natural numbers

```python
def infinite_numbers():
    n = 1
    while True:
        yield n
        n += 1

gen = infinite_numbers()
for _ in range(5):  # print first 5
    print(next(gen))
```

### âœ… 6. Prime numbers up to n

```python
def is_prime(num):
    if num < 2:
        return False
    for i in range(2, int(num**0.5)+1):
        if num % i == 0:
            return False
    return True

def primes(n):
    for i in range(2, n+1):
        if is_prime(i):
            yield i

print(list(primes(20)))  # [2, 3, 5, 7, 11, 13, 17, 19]
```

---

âœ… Now you have **Recursion, Lambda, Iterator, and Generator** all in the same structured format (Definition â†’ Key points â†’ Example â†’ Real-life analogy â†’ Tasks â†’ Solved tasks).

Do you want me to **combine all four into a single PDF/Word file** (like lecture notes for your students at UNIQ Technology)?
